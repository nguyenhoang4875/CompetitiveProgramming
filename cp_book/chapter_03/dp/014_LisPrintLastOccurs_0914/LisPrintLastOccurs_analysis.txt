PROBLEM SUMMARY:
- Task: [Short task description]
    cho n và mảng n phần tử
    in ra độ dài dãy tăng dần, nếu có nhiều dãy giống nhau in ra dãy xuất hiện cuối cùng
- Constraints: [Important limits]
    O(n log n)
- Time/Space: [Required complexity]

KEY IDEAS:
- [Key idea 1]
- [Key idea 2]

APPROACH:
- [Algorithm or method]

    int n = a.size();
    vi f(n, oo); // LIS
    vi pos(n, -1), pre_pos(n, -1); // pos: last pos for i-th index, pre_pos: pre last index for pos[i] 
    int len = 0;

    for (int i = 0; i < n; i++) {
        int e = a[i];
        int idx = lower_bound(all(f), e) - f.begin();
        f[idx] = e;
        pos[idx] = i;
        if (idx > 0) pre_pos[i] = pos[idx - 1]; // update pre_pos[i]
        if (idx + 1 > len) len = idx + 1; // update len
    }

    vi ans;
    int last_idx = pos[len - 1];
    while (last_idx != -1) {
        ans.push_back(a[last_idx]);
        last_idx = pre_pos[last_idx];
    }
    reverse(all(ans));

- [Main steps]

EDGE CASES:
- [Special cases to watch for]
