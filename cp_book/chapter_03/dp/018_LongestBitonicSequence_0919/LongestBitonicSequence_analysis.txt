PROBLEM SUMMARY:
- Task: [Short task description]
    Longest Bitonic Subsequence:
    Given an array a containing n positive integers, a subsequence of numbers is called bitonic
    if it is first strictly increasing, then strictly decreasing.
    The task is to find the length of the longest bitonic subsequence.

    Để tìm tăng xong rồi giảm:
    Tìm tăng dần từ trái qua phải, l
    Tìm tăng dần từ phải qua trái, r 
    Rep(i, n) ans = min(ans, l[i] + r[i] - 1)

    Example: Train sorting (biến thể của bitonnic)
    Cho n train xuất hiện theo thứ tự. với mỗi train có thể thêm vào đầu hàng, hoặc cuối hàng, hoặc không thêm vào hàng
    Tìm độ dài lớn nhất của hàng sao cho train từ đầu đến cuối hàng sắp xếp theo thứ tự giảm dần.

    mục đính là thành dãy: b[0], b[i], .... b[k] sao cho dãy b giảm dần

    Mục tiêu tìm i và 2 dãy j1, j2, ... jk sao cho dãy i, j1, j2, ..., jk  là dãy tăng dần tăng dần i < j1 < j2 ... < jk (1) 
    Mục tiêu tìm i và 2 dãy t1, t2, ... tm sao cho dãy i, t1, t2, ..., tm  là dãy tăng giarm tăng dần i < t1 < t2 ... < tm (2)

    Ta có thể sắp xếp theo chiều giảm có index là: tm, ..., t2, t1, i, j1, j2, ... jk  là dãy giảm
    => Bài toán trở thành từ i tìm dãy tăng dần và giảm dần
    Mình cần i là đứng đầu hàng để những những tàu sau tới có thể sắp xếp
    Tìm từ tăng đần phải qua trái, l
    Tìm giảm dần từ phải qua trái, r
    Rep(i, n) ans = min(ans, l[i] + r[i] - 1)


- Constraints: [Important limits]
    1 <= n <= 5000
- Time/Space: [Required complexity]
    O(n^2)

KEY IDEAS:
- [Key idea 1]
- [Key idea 2]

APPROACH:
- [Algorithm or method]
    Tăng rồi giảm:

    vector<int> l(n, 1), d(n, 1);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (a[i] > a[j]) l[i] = max(l[i], l[j] + 1);
        }
    }

    for (int i = n - 1; i >= 0; --i) {
        for (int j = n - 1; j > i; --j) {
            if (a[i] > a[j]) d[i] = max(d[i], d[j] + 1);
        }
    }
    int ans = 0;
    for (int i = 0; i < n; ++i) ans = max(ans, l[i] + d[i] - 1);


    Tăng dần và giảm dần từ index i về sau 
    
    int n = a.size();
    vector<int> l(n, 1), d(n, 1);
    for (int i = n - 1; i >= 0; --i) {
        for (int j = n - 1; j > i; --j) {
            if (a[i] < a[j]) l[i] = max(l[i], l[j] + 1);
            if (a[i] > a[j]) d[i] = max(d[i], d[j] + 1);
        }
    }
    int ans = 0;
    for (int i = 0; i < n; ++i) ans = max(ans, l[i] + d[i] - 1);

- [Main steps]

EDGE CASES:
- [Special cases to watch for]
