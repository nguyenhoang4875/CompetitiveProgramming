PROBLEM SUMMARY:
- Task: [Short task description]
    Cho n, k: đếm số set  có k số nguyên tố khác nhau có tổng bằng n 

- Constraints: [Important limits]
    1 <= n <= 1120
    1 <= k <= 14

- Time/Space: [Required complexity]
    m là số lượng số nguyên tố <= n
    TC: O(K × m × N)

KEY IDEAS:
- [Key idea 1]

- [Key idea 2]

APPROACH:
- [Algorithm or method]
    DP top down
        // p là vi chưa số nguyên tố <= n
        int m = p.size(); //
        vector<vvi> memo(k + 1, vvi(m + 1, vi(n + 1, -1)));
        // f(k, idx, n): là số cách tạo tổng là n, với k phần tử sửa dụng idx số nguyên tố đầu tiên
        // base case k = 0: if n == 0: 1 else: 0

        function<int(int, int, int)> f = [&](int k, int idx, int n) {
            if (k == 0) {
                if (n == 0) return 1;
                return 0;
            }
            if (idx < 0) return 0;
            int& ans = memo[k][idx][n];
            if (ans != -1) return ans;

            int v1 = f(k, idx - 1, n);
            int v2 = 0;
            if (n >= p[idx]) v2 = f(k - 1, idx - 1, n - p[idx]);
            ans = v1 + v2;
            return ans;
        };

        cout << f(k, m - 1, n) << el

    Top down:

        vector<vvi> dp(k + 1, vvi(m + 1, vi(n + 1, 0)));

        // Base case: dp[0][i][0] = 1 for all i
        for (int i = 0; i <= m; i++) {
            dp[0][i][0] = 1;
        }

        // Fill the DP table bottom-up
        for (int curr_k = 1; curr_k <= k; curr_k++) {
            for (int idx = 1; idx <= m; idx++) {
                for (int curr_n = 0; curr_n <= n; curr_n++) {
                    // Don't take current prime
                    dp[curr_k][idx][curr_n] = dp[curr_k][idx - 1][curr_n];

                    // Take current prime if possible
                    if (curr_n >= p[idx - 1]) {
                        dp[curr_k][idx][curr_n] += dp[curr_k - 1][idx - 1][curr_n - p[idx - 1]];
                    }
                }
            }
        }

        cout << dp[k][m][n] << el;


- [Main steps]

EDGE CASES:
- [Special cases to watch for]
